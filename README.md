# Служебная записка

В проекте использовал:
- __typescript__
- __БЭМ__, __scss modules__
- __redux-toolkit__ для управления состоянием приложения
- для управления состоянием форм использовал __Formik__
- __exceljs__ для печати формы в формате excel, при этом также в функции exportNotesOptionsFormToExcel настроил вид excel таблицы при печати(центрировал по горизонтали, выбрал лист A4 и опцию вписать лист на одну страницу), добавил логику автоматического определения высоты строки, исходя из количества символов в ячейке с данными формы
- __react-datepicker__
- __google-fonts__ для установки шрифта из макета figma
- так как нет сервера, то использую библиотеку __uuid__ для формирования id на стороне клиента
- типизировал scss модули с помощью __typescript-plugin-css-modules__
- Для того, чтобы соединить классы в строку использовал самодельный метод cls, вместо библиотеки classnames

Верстал по макету из фигма, стараясь попадать пиксель в пиксель, но форму авторизацию решил уменьшить, иначе получалась слишком большая. Хранил данные в redux-toolkit, но собираюсь сделать сервер с помощью json-server или node.js и получать данные с помощью RTK-query, по этой же причине не стал углубляться в реализацию функции handleSubmit для компоненты AuthForm, поскольку планирую в дальнейшем реализовать полноценную авторизацию с запросами к серверу(сделал проверку логина и пароля через if, если логин и пароль правильные, то отправляется action setCurrentUser, в котором устанавливается currentUser и isAuth, в случае, когда isAuth=false, при переходе на страницу пользователя - компонент Main, происходит редирект на страницу авторизации - компонент Auth). Для изменения массива notes с данными в notes.slice.ts создал action'ы editNote, addNote, deleteNote.

Форму служебной записки реализовал в виде модального окна(компонент NotesOptionsFormModal, который отображается при создании и редактировании служебной заметки), добавил выход при клике на overlay у модального окна(функция handleOverlayClick) с плавным переходом visibility, opacity. В компоненте формы решил разделить логику отправки формы и валидации данных на функции handleSubmit и validateFields соответственно, в handleSubmit объект actionHandlers по ключу(в качестве ключа передаётся submitBtnClicked - нажатая пользователем кнопка) возвращает функцию, которая выполняет логику в зависимости от нажатой кнопки(у служебной заметки меняются поля и статус в соответствии с бизнес-процессом из pdf файла).

В компоненте NotesOptionsFormBtns, исходя из роли пользователя отображаются соответствующие кнопки(На согласование/На регистрацию/Согласовать/Подписать и т.д).

Для определения режима для чтения(переменная isReadOnly) в NotesOptionsFormikForm соотносится статус заметки и роль пользователя(при условии, что данная форма открыта в режиме редактирования - notesOptionsEditMode).

В компоненте NotesOptionsFormFields учёл, что поля рег.дата и рег.номер становятся недоступными(disabled) для всех пользователей, кроме пользователя с ролью "Регистратор"(переменная isRegistrarsInputDisabled) и комбобоксы "Исполнитель", "Согласующий", "Подписант", "Регистратор" доступны только исполнителю(переменная isPeopleInfoInputDisabled)

В NotesOptionsBtns кнопка «Создать» доступна только пользователю «Исполнитель», для остальных пользователей данная кнопка недоступна (disabled). Также сделал кнопки удалить и редактировать недоступными в случае, когда пользователь ещё не выбрал служебную заметку(ещё не нажал на строку в таблице с служебной заметкой - переменная isNoteSelected). То есть пользователь сначала выбирает заметку для редактирования/удаления, нажимая на строчку в таблице с заметкой, а потом на кнопку с действием: создать/редактировать/удалить.

Используя scss миксины, вынес повторяющиеся стили, в дополнение к этому создал отдельные файлы для хранения переменных с размером шрифтов и цветами приложения.

Избавился от лишних перерисовок при вводе текста в input для NotesOptionsFormFields, NotesOptionsFormBtns, NotesOptionsFormHeader, использовав useMemo.

Для того, чтобы упростить работу с action'ами и не использовать каждый раз dispatch, добавил хук useActions. Для упрощения работы со стейтом добавил хук useAppSelector.

Реализовал пагинацию, храня текущие отображаемые служебные записки в currentNotes в notes.slice.ts, при клике на кнопки в пагинаторе вызывается функция onChangePage, которая устанавливает текущую страницу currentPage и текущую часть массива notes в currentNotes, отправляя action setCurrentNotes() и setCurrentPage(), также синхронизировал notes и currentNotes с помощью useEffect для того, чтобы при редактировании массива notes обновлялись данные в currentNotes и в таблице NotesListTable хранились актуальные данные о служебных записках.